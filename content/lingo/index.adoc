---
title: "Python Lingo"
date: 2021-07-28T12:59:00-03:00
draft: false
---

Many terms here are not exclusive to Python, but some common terms have definitions that are specific to the Python community.

Also see the official https://docs.python.org/3/glossary.html[Python Glossary].

Contents:
<<A,A>> <<B,B>> <<C,C>> <<D,D>> <<E,E>> <<F,F>> <<G,G>> <<H,H>> <<I,I>> <<K,K>> <<L,L>> <<M,M>>
<<N,N>> <<O,O>> <<P,P>> <<R,R>> <<S,S>> <<T,T>> <<U,U>> <<V,V>> <<W,W>> <<Y,Y>> <<Z,Z>>

[glossary]

[[A]]

[[ABC_programming_language]]ABC (programming language):: (((ABC language)))A programming language created by Leo Geurts, Lambert Meertens, and Steven Pemberton. Guido van Rossum, who developed Python, worked as a programmer implementing the ABC environment in the 1980s. Block structuring by indentation, built-in tuples and dictionaries, tuple unpacking, the semantics of the `for` loop, and uniform handling of all <<sequence>> types are some of the distinctive characteristics of Python that came from the ABC language.

[[ABC]]Abstract base class (ABC):: ((("ABC (Abstract Base Class)", "definition of term")))A class that cannot be instantiated, only subclassed. ABCs are how interfaces are formalized in Python. Instead of inheriting from an ABC, a class may also declare that it fulfills the interface by registering with the ABC to become a <<virtual_subclass>>.

[[accessor]]accessor:: (((accessor methods)))(((methods, accessor)))(((mutators)))A method implemented to provide access to a single data attribute. Some authors use _accessor_ as a generic term encompassing getter and setter methods, others use it to refer only to getters, referring to setters as _mutators_.

[[alias]]alias:: (((alias)))An alternative name for an object. For example, in `a = []; b = a` the variable `b` is an alias to the list bound to `a`.

[[aliasing]]aliasing:: (((aliasing)))Binding two or more names to the same object. Aliasing happens naturally all the time in any language where variables and function parameters hold references to objects. To avoid confusion, just forget the idea that variables are boxes that store objects (an object can't be in two boxes at the same time). It's better to think of them as labels attached to objects (an object can have more than one label). See <<alias>>.

[[argument]]argument:: (((arguments, definition of term)))An expression passed to a function when it is called. In Pythonic parlance, _argument_ and <<parameter>> are often used as synonyms. To be more specific, some authors write "actual argument" to contrast with "formal parameter". See <<parameter>> for more about the distinction and usage of these terms.

[[attribute]]attribute:: (((attributes, definition of term)))Methods and data attributes (i.e., "fields" in Java terms) are all known as attributes in Python. A method is just an attribute that happens to be a callable object (usually a function, but not necessarily).

[[B]]

[[BDFL]]BDFL:: ((("BDFL (Benevolent Dictator For Life)")))Benevolent Dictator For Life, alias for Guido van Rossum, creator of the Python language. Since https://www.python.org/dev/peps/pep-0013/[PEP 13—Python Language Governance] was adopted in December 2018, the powers of the BDFL are now in the hands of a Steering Council, and Guido is the "BDFL emeritus."

[[binary_sequence]]binary sequence:: (((binary sequences, definition of term)))(((sequences, binary)))Generic term for sequence types with byte elements. The built-in binary sequence types are `byte`, `bytearray`, and `memoryview`.

[[BOM]]BOM:: ((("BOM (Byte Order Mark)")))Byte Order Mark, a sequence of bytes that may be present at the start of a UTF-16 encoded file. A BOM is the character U+FEFF (`ZERO WIDTH NO-BREAK SPACE`) encoded to produce either `b'\xfe\xff'` on a big-endian CPU, or `b'\xff\xfe'` on a little-endian one. Because there is no U+FFFE characer in Unicode, the presence of these bytes unambiguously reveals the byte ordering used in the encoding. Although redundant, a BOM encoded as `b'\xef\xbb\xbf'` may be found in UTF-8 files saved by some Microsoft applications, and is also required by Excel when reading text files. To read or write such files with Python, use the `UTF-8-SIG` https://docs.python.org/3/library/codecs.html#encodings-and-unicode[codec].

[[bound_method]]bound method:: (((bound methods)))(((methods, bound)))A method that is accessed through an instance becomes bound to that instance. Any method is actually a descriptor. When accessed, a method returns itself wrapped in an object that binds the method to the _receiver_. That object is the bound method. It can be invoked without passing the value of `self`. For example, given the assignment `my_method = my_obj.method`, the bound method can later be called as `my_method()`. Contrast with <<unbound method>>. See <<receiver>>.

[[built-in_function]]built-in function (BIF):: ((("BIF", see="built-in functions")))((("built-in functions")))((("functions", "built-in")))A function bundled with the Python interpreter, coded in the implementation language of the interpreter (i.e., C for CPython; Java for Jython, and so on). The term often refers only to the functions that don't need to be imported, documented in http://docs.python.org/library/functions.html[Chapter 2, "Built-in Functions,"] of The Python Standard Library Reference. However, built-in modules like `sys`, `math`, `re`, etc. also contain built-in functions.

[[byte_string]]byte string:: (((byte strings)))An unfortunate name still used to refer to `bytes` or `bytearray` in Python 3. In Python 2, the `str` type was really a byte string, and the term made sense to distinguish `str` from `unicode` strings. In Python 3, it makes no sense to insist on this term, and I tried to use _byte sequence_ whenever I needed to talk in general about...byte sequences.

[[bytes-like_object]]bytes-like object:: ((("bytes-like objects")))(((objects, bytes-like)))A generic sequence of bytes. The most common bytes-like types are `bytes`, `bytearray`, and `memoryview` but other objects supporting the low-level CPython buffer protocol also qualify, if their elements are single bytes.

[[C]]

[[callable_object]]callable object:: ((("callable objects")))(((objects, callable)))An object that can be invoked with the call operator `()`, to return a result or to perform some action. There are nine flavors of callable objects in Python: user-defined functions, built-in functions, built-in methods, instance methods, generator functions, asynchronous generator functions, coroutines, classes, and instances of classes that implement the `+__call__+` special method.

[[CamelCase]]CamelCase:: ((("CamelCase")))The convention of writing identifiers by joining words with uppercased initials (e.g., `ConnectionRefusedError`). PEP-8 recommends class names should be written in CamelCase, but the advice is not followed by the Python standard library. See <<snake_case>>.

[[Cheese_Shop]]Cheese Shop:: ((("Cheese Shop")))Original name of the https://pypi.python.org/pypi[Python Package Index] (PyPI), after the Monty Python skit about a cheese shop where nothing is available. As of this writing, the alias https://cheeseshop.python.org still works. See <<PyPI>>.

[[class]]class:: (((classes, definition of term)))A program construct defining a new type, with data attributes and methods specifying possible operations on them. See <<type>>.

[[code_point]]code point:: (((code point)))An integer in the range 0 to 0x10FFFF used to identify an entry in the Unicode character database. As of Unicode 7.0, less than 3% of all code points are assigned to characters. In the Python documentation, the term may be spelled as one or two words. For example, in http://docs.python.org/library/functions.html[Chapter 2, "Built-in Functions,"] of the _Python Library Reference_, the `chr` function is said to take an integer "codepoint," while its inverse, `ord`, is described as returning a "Unicode code point."

[[code_smell]]code smell:: ((("code smell")))A coding pattern that suggests there may be something wrong with the design of a program. For example, excessive use of `isinstance` checks against concrete classes is a code smell, as it makes the program harder to extend to deal with new types in the future.

[[codec]]codec:: (encoder/decoder) ((("codec module")))A module with functions to encode and decode, usually from `str` to `bytes` and back, although Python has a few codecs that perform `bytes` to `bytes` and `str` to `str` transformations.

[[collection]]collection:: (((collections, definition of term)))Generic term for data structures made of items that can be accessed individually. Some collections can contain objects of arbitrary types (see <<container>>) and others only objects of a single atomic type (see <<flat_sequence>>). `list` and `bytes` are both collections, but `list` is a <<container>>, and `bytes` is a <<flat_sequence>>.

[[considered_harmful]]considered harmful:: ((("&#x0022;Considered Harmful&#x0022; article", sortas="Considered Harmful")))Edsger Dijkstra's letter titled "Go To Statement Considered Harmful" established a formula for titles of essays criticizing some computer science technique. Wikipedia's http://en.wikipedia.org/wiki/Considered_harmful["Considered harmful" article] lists several examples, including http://meyerweb.com/eric/comment/chech.html["'Considered Harmful' Essays Considered Harmful"] by Eric A. Meyer.

[[constructor]]constructor:: ((("constructors, definition of term")))Informally, the `+__init__+` instance method of a class is called its constructor, because its semantics is similar to that of a Java constructor. A better term for `+__init__+` is _initializer_, as the method does not actually build the instance, but receives it as its `self` argument. The _constructor_ term better describes the `+__new__+` class method, which Python calls before `+__init__+`, and is responsible for actually creating an instance and returning it. See <<initializer>>.

[[container]]container:: ((("containers, definition of term")))An object that holds references to other objects. Most collection types in Python are containers, but some are not. The term is defined in section https://docs.python.org/3/reference/datamodel.html#objects-values-and-types[3.1. Objects, values and types] of the _Python Data Model_ documentation: "Some objects contain references to other objects; these are called containers. Examples of containers are tuples, lists and dictionaries." Contrast with <<flat_sequence>>, which are collections but not containers. Also see <<container_ABC>> for a different definition.

[[container_ABC]]Container (ABC):: ((("container ABC, definition of term")))The <<ABC>> defined in `collections.abc.Container`, with a single method `+__contains__+` which implements the `in` operator. The `str` and `array.array` types are <<virtual_subclass,virtual subclasses>> of `Container`, but they are not containers in the other definition of <<container>>.

[[context_manager]]context manager:: (((context managers, definition of term)))(((objects, context managers)))An object implementing both the `+__enter__+` and `+__exit__+` special methods, for use in a `with` block.

[[coroutine]]coroutine:: (((coroutines, definition of term)))A generator used for concurrent programming by receiving values from a scheduler or an event loop via `coro.send(value)`. The term may be used to describe the generator function or the generator object obtained by calling the generator function. See <<generator>>.

[[CPython]]CPython:: (((CPython)))The standard Python interpreter, implemented in C. This term is only used when discussing implementation-specific behavior, or when talking about the multiple Python interpreters available, such as _PyPy_.

[[CRUD]]CRUD:: ((("CRUD (Create, Read, Update, and Delete)")))Acronym for Create, Read, Update, and Delete, the four basic functions in any application that stores records.

[[D]]

[[decorator]]decorator:: (((decorators and closures, definition of decorators)))(((objects, decorators)))A callable object `A` that returns another callable object `B` and is invoked in code using the syntax `@A` right before the definition of a callable `C`. When reading such code, the Python interpreter invokes `A(C)` and binds the resulting `B` to the variable previously assigned to `C`, effectively replacing the definition of `C` with `B`. If the target callable `C` is a function, then `A` is a function decorator; if `C` is a class, then `A` is a class decorator.

[[deep_copy]]deep copy:: (((deep copies)))(((objects, deep copies of)))A copy of an object in which all the objects that are attributes of the object are themselves also copied. Contrast with <<shallow_copy>>.

[[descriptor]]descriptor:: (((descriptors, definition of term)))(((classes, descriptor)))A class implementing one or more of the `+__get__+`, `+__set__+`, or `+__delete__+` special methods acts as a descriptor when one of its instances is used as a class attribute of another class, the <<managed_class>>. A descriptor manages the access and deletion of a <<managed_attribute>> in the <<managed_instances,managed instance>>. For example, in a https://docs.djangoproject.com/en/3.2/topics/db/models/[Django model], the user's `model.Model` subclass is the <<managed_class>>, the fields are descriptors, and each record is a <<managed_instance>>.

[[docstring]]docstring:: ((("docstrings (documentation strings)")))Short for documentation string. When the first statement in a module, class, or function is a string literal, it is taken to be the _docstring_ for the enclosing object, and the interpreter saves it as the `+__doc__+` attribute of that object. See also <<doctest>>.

[[doctest]]doctest:: ((("doctest testing package", "definition of term")))A module with functions to parse and run examples embedded in the docstrings of Python modules or in plain-text files. May also be used from the command line as:
+
----
python -m doctest module_with_tests.py
----

[[DRY]]DRY:: ((("DRY (Don't Repeat Yourself) principle")))Don't Repeat Yourself--a software engineering principle stating that "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system." It first appeared in the book _The Pragmatic Programmer_ by Andy Hunt and Dave Thomas (Addison-Wesley, 1999).

[[duck_typing]]duck typing:: (((duck typing, definition of term)))A form of polymorphism where functions operate on any object that implements the appropriate methods, regardless of their classes or explicit interface declarations.

[[dunder]]dunder:: ((("double underscore (dunder)")))Shortcut to pronounce the names of _special methods_ and attributes that are written with leading and trailing double-underscores (i.e., `+__len__+` is read as "dunder len").

[[dunder_method]]dunder method:: See <<dunder>> and <<special_method>>.

[[E]]

[[EAFP]]EAFP:: ((("EAFP principle")))Acronym standing for the quote "It's easier to ask forgiveness than permission," attributed to computer pioneer Grace Hopper, and quoted by Pythonistas referring to dynamic programming practices like accessing attributes without testing first if they exist, and then catching the exception when that is the case. The docstring for the `hasattr` function actually says that it works "by calling getattr(object, name) and catching AttributeError."

[[eager]]eager:: (((eager objects)))(((objects, eager)))An iterable object that builds all its items at once. In Python, a _list comprehension_ is eager. Contrast with <<lazy>>.

[[F]]

[[fail-fast]]fail-fast:: (((fail-fast design)))A systems design approach recommending that errors should be reported as early as possible. Python adheres to this principle more closely than most dynamic languages. For example, there is no "undefined" value: variables referenced before initialization generate an error, and `my_dict[k]` raises an exception if `k` is missing (in contrast with JavaScript). As another example, parallel assignment via tuple unpacking in Python only works if every item is explicitly handled, while Ruby silently deals with item count mismatches by ignoring unused items on the right side of the `=`, or by assigning `nil` to extra variables on the left side.

[[falsy]]falsy:: (((falsiness)))Any value `x` for which `bool(x)` returns `False`; Python implicitly calls `bool(…)` to evaluate objects in Boolean contexts, such as the expression controlling an `if` or `while` loop. The `bool` function considers _falsy_: `False`, `None`, any number equal to zero, any sequence or collection with length zero, any object with a `+__bool__+` method that returns `False`. By convention, all other objects are <<truthy>>.

[[file-like_object]]file-like object:: (((file-like objects)))(((objects, file-like)))Used informally in the official documentation to refer to objects implementing the file protocol, with methods such as `read`, `write`, `close`, etc. Common variants are text files containing encoded strings with line-oriented reading and writing, `StringIO` instances which are in-memory text files, and binary files, containing unencoded bytes. The latter may be buffered or unbuffered. ABCs for the standard file types are defined in the `io` module since Python 2.6.

[[first-class_function]]first-class function:: ((("first-class functions", "definition of term")))(((functions, first-class)))Any function that is a first-class object in the language (i.e., can be created at runtime, assigned to variables, passed as an argument, and returned as the result of another function). Python functions are first-class functions.

[[flat_sequence]]flat sequence:: (((flat sequences)))(((sequences, flat)))A sequence type that physically stores the values of its items, and not references to other objects. The built-in types `str`, `bytes`, `bytearray`, `memoryview`, and `array.array` are flat sequences. Contrast with `list`, `tuple`, and `collections.deque`, which are container sequences. See <<container>>.

[[function]]function:: (((functions, definition of term)))Strictly, an object resulting from evaluation of a +def+ block or a +lambda+ expression. Informally, the word _function_ is used to describe any callable object, such as methods and even classes sometimes. The official http://docs.python.org/library/functions.html[Built-in Functions] list includes several built-in classes like `dict`, `range`, and `str`. Also see <<callable object>>.

[[G]]

[[genexp]]genexp:: Short for _generator expression_.

[[generator]]generator:: (((generators, definition of term)))An iterator built with a generator function or a generator expression that may produce values without necessarily iterating over a collection; the canonical example is a generator to produce the Fibonacci series which, because it is infinite, would never fit in a collection. The term is sometimes used to describe a _generator function_, besides the object that results from calling it.

[[generator_function]]generator function:: (((generator functions, definition of term)))(((functions, generator)))A function that has the `yield` keyword in its body. When invoked, a generator function returns a <<generator>>.

[[generator_expression]]generator expression:: ((("generator expressions (genexps)", "definition of term")))An expression enclosed in parentheses using the same syntax of a _list comprehension_, but returning a generator instead of a list. A _generator expression_ can be understood as a _lazy_ version of a _list comprehension_. See <<lazy>>.

[[generic_function]]generic function:: (((generic functions)))(((functions, generic)))A group of functions designed to implement the same operation in customized ways for different object types. As of Python 3.4, the `functools.singledispatch` decorator is the standard way to create generic functions. This is known as multimethods in other languages.

[[GoF_book]]GoF book:: ((("GoF (Gang of Four)")))Alias for _Design Patterns: Elements of Reusable Object-Oriented Software_ (Addison-Wesley, 1995), authored by the so-called Gang of Four (GoF): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.

[[H]]

[[hashable]]hashable:: (((hashable objects)))(((objects, hashable)))An object is hashable if it has both `+__hash__+` and `+__eq__+` methods, with the constraints that the hash value must never change and if `a == b` then `hash(a) == hash(b)` must also be `True`. Most immutable built-in types are hashable, but a tuple is only hashable if every one of its items is also hashable.

[[higher-order_function]]higher-order function:: (((higher-order functions)))(((functions, higher-order)))A function that takes another function as argument, like `sorted`, `map`, and `filter`, or a function that returns a function as result, as Python decorators do.

[[I]]

[[idiom]]idiom:: ((("idiom, definition of term")))"A manner of speaking that is natural to native speakers of a language," according to the Princeton WordNet.

[[import_time]]import time:: (((import time)))The moment of initial execution of a module when its code is loaded by the Python interpreter, evaluated from top to bottom, and compiled into bytecode. This is when classes and functions are defined and become live objects. This is also when decorators are executed.

[[initializer]]initializer:: ((("initializers, definition of term")))A better name for the `+__init__+` method (instead of _constructor_). Initializing the instance received as `self` is the task of `+__init__+`. Actual instance construction is done by the `+__new__+` method. See <<constructor>>.

[[iterable]]iterable:: (((iterable objects)))(((objects, iterable)))Any object from which the `iter` built-in function can obtain an iterator. An iterable object works as the source of items in +for+ loops, comprehensions, and tuple unpacking. Objects implementing an `+__iter__+` method returning an _iterator_ are iterable. Sequences are always iterable; other objects implementing a `+__getitem__+` method may also be iterable.

[[iterable_unpacking]]iterable unpacking:: (((iterable unpacking)))A modern, more precise synonym for _tuple unpacking_. See also <<parallel assignment>>.

[[iterator]]iterator:: (((iterators, definition of term)))(((objects, iterators)))Any object that implements the `+__next__+` no-argument method, which returns the next item in a series, or raises `StopIteration` when there are no more items. Python iterators also implement the `+__iter__+` method so they are also _iterable_. Classic iterators, according to the original design pattern, return items from a collection. A _generator_ is also an _iterator_, but it's more flexible. See <<generator>>.

[[K]]

[[KISS_principle]]KISS principle:: ((("KISS (Keep It Simple, Stupid) principle")))The acronym stands for "Keep It Simple, Stupid." This calls for seeking the simplest possible solution, with the fewest moving parts. The phrase was coined by Kelly Johnson, a highly accomplished aerospace engineer who worked in the real Area 51 designing some of the most advanced aircraft of the 20th century.

[[L]]

[[lazy]]lazy:: (((lazy objects)))(((objects, lazy)))An iterable object that produces items on demand. In Python, generators are lazy. Contrast <<eager>>.

[[listcomp]]listcomp:: Short for <<list_comprehension>>.

[[list_comprehension]]list comprehension:: ((("list comprehensions (listcomps)", "definition of term")))An expression enclosed in brackets that uses the `for` and `in` keywords to build a list by processing and filtering the elements from one or more iterables. A list comprehension works eagerly. See <<eager>>.

[[liveness]]liveness:: (((liveness property)))An asynchronous, threaded, or distributed system exhibits the liveness property when "something good eventually happens" (i.e., even if some expected computation is not happening right now, it will be completed eventually). If a system deadlocks, it has lost its liveness.

[[M]]

[[magic_method]]magic method:: Same as <<special_method>>.

[[managed_attribute]]managed attribute:: (((managed attribute)))(((attributes, managed)))A public attribute managed by a <<descriptor>> object. Although the _managed attribute_ is defined in the <<managed_class>>, it operates like an instance attribute (i.e., it usually has a value per instance, held in a <<storage_attribute>>). See <<descriptor>>.

[[managed_class]]managed class:: (((managed class)))(((class, managed)))A class that uses a descriptor object to manage one of its attributes. See <<descriptor>>.

[[managed_instance]]managed instance:: (((managed instances)))(((instances, managed)))An instance of a <<managed_class>>. See <<descriptor>>.

[[metaclass]]metaclass:: (((metaclass, definition of term)))(((class, metaclass)))A class whose instances are classes. By default, Python classes are instances of `type`, for example, `type(int)` is the class `type`, therefore `type` is a metaclass. User-defined metaclasses can be created by subclassing `type`.

[[metaprogramming]]metaprogramming:: ((("metaprogramming")))The practice of writing programs that use runtime information about themselves to change their behavior. For example, an _ORM_ may introspect model class declarations to determine how to validate database record fields and convert database types to Python types.

[[monkey_patching]]monkey patching:: ((("monkey patching")))Dynamically changing a module, class, or function at runtime, usually to add features or fix bugs. Because it is done in memory and not by changing the source code, a monkey patch only affects the currently running instance of the program. Monkey patches break encapsulation and tend to be tightly coupled to the implementation details of the patched code units, so they are seen as temporary workarounds and not a recommended technique for code integration.

[[mixin_class]]mixin class:: (((mixin classes)))(((classes, mixin)))A class designed to be subclassed together with one or more additional classes in a multiple-inheritance class tree. A mixin class should never be instantiated, and a concrete subclass of a mixin class should also subclass another nonmixin class.

[[mixin_method]]mixin method:: (((mixin methods)))(((methods, mixin)))A concrete method implementation provided in an ABC or in a _mixin class_.

[[mutator]]mutator:: See <<accessor>>.

[[N]]

[[name_mangling]]name mangling:: (((name mangling)))The automatic renaming of private attributes from `+__x+` to `_MyClass__x`, performed by Python at runtime.

[[nonoverriding_descriptor]]nonoverriding descriptor:: ((("nonoverriding descriptors")))(((descriptors, nonoverriding)))A _descriptor_ that does not implement `+__set__+` and therefore does not interfere with setting of the _managed attribute_ in the _managed instance_. Consequently, if a namesake attribute is set in the _managed instance_, it will shadow the descriptor in that instance. Also called nondata descriptor or shadowable descriptor. Contrast with <<overriding descriptor>>.

[[O]]

[[ORM]]ORM:: ((("ORM (Object-Relational Mapper)")))Object-Relational Mapper--an API that provides access to database tables and records as Python classes and objects, providing method calls to perform database operations. SQLAlchemy is a popular standalone Python ORM; the Django and Web2py frameworks have their own bundled ORMs.

[[overriding_descriptor]]overriding descriptor:: ((("overriding descriptors")))(((descriptors, overriding)))A _descriptor_ that implements `+__set__+` and therefore intercepts and overrides attempts at setting the _managed attribute_ in the _managed instance_. Also called data descriptor or enforced descriptor. Contrast with <<non-overriding_descriptor>>.

[[P]]

[[parallel_assignment]]parallel assignment:: (((parallel assignment)))(((destructuring assignment)))(((assignment, parallel)))(((assignment, destructuring)))Assigning to several variables from items in an iterable, using syntax like ++a, b = [c, d]++—also known as destructuring assignment. This is a common application of _tuple unpacking_.

[[parameter]]parameter:: (((parameters, definition of term)))Functions are declared with 0 or more "formal parameters," which are unbound local variables. When the function is called, the _arguments_ or "actual arguments" passed are bound to those variables. In _Fluent Python_, I tried to use _argument_ to refer to an actual argument passed to a function, and _parameter_ for a formal parameter in the function declaration. However, that is not always feasible because the terms _parameter_ and _argument_ are used interchangeably throughout the Python documentation and API. See <<argument>>.

[[to_prime]]prime (verb):: ((("prime, definition of term")))Calling `next(coro)` on a coroutine to advance it to its first `yield` expression so that it becomes ready to receive values in succeeding `coro.send(value)` calls.

[[PyPI]]PyPI:: ((("PyPI (The Python Package Index)")))The https://pypi.python.org[Python Package Index], where more than 60,000 packages are available, also known as the [[Cheese_shop]]). PyPI is pronounced as "pie-P-eye" to avoid confusion with _PyPy_.

[[PyPy]]PyPy:: (((PyPy language)))An alternative implementation of the Python programming language using a toolchain that compiles a subset of Python to machine code, so the interpreter source code is actually written in Python. PyPy also includes a JIT to generate machine code for user programs on the fly--like the Java VM does. As of November 2014, PyPy is 6.8 times faster than CPython on average, according to http://speed.pypy.org[published benchmarks]. PyPy is pronounced as "pie-pie" to avoid confusion with _PyPI_.

[[Pythonic]]Pythonic:: ((("Pythonic, definition of term")))Used to praise idiomatic Python code, that makes good use of language features to be concise, readable, and often faster as well. Also said of APIs that enable coding in a way that seems natural to proficient Python programmers. See <<idiom>>.

[[R]]

[[receiver]]receiver:: (((receiver)))The object to which a method call is applied; e.g. the `x` in `x.play()`. The first parameter of the method (conventionally named `self`) is bound to the receiver. See <<bound_method>>.

[[refcount]]refcount:: ((("reference counting (refcount)")))The reference counter that each CPython object keeps internally in order to determine when it can be destroyed by the garbage collector. See <<strong_reference>> and <<weak_reference>>.

[[referent]]referent:: (((referent objects)))(((objects, referent)))The object that is the target of a reference. This term is most often used to describe the target of a <<weak_reference>>.

[[REPL]]REPL (Read-eval-print loop):: ((("REPL (Read-eval-print-loop)")))An interactive console, like the standard `python` prompt `>>>` or alternatives like `ipython`, `bpython`, and https://www.pythonanywhere.com/[Python Anywhere].

[[S]]

[[sequence]]sequence:: (((sequences, definition of term)))Generic name for any iterable data structure with a known size (e.g., `len(s)`) and allowing item access via 0-based integer indexes (e.g., `s[0]`). The word _sequence_ has been part of the Python jargon from the start, but only in Python 2.6 it was formalized as an <<ABC,ABC>> in `collections.abc.Sequence`.

[[serialization]]serialization:: (((serialization)))(((objects, serialization of)))Converting an object from its in-memory structure to a binary or text-oriented format for storage or transmission, in a way that allows the future reconstruction of a clone of the object on the same system or on a different one. The `pickle` module supports serialization of arbitrary Python objects to a binary format.

[[shallow_copy]]shallow copy:: (((shallow copies)))(((objects, shallow copies of)))A copy of an object which shares references to all the objects that are attributes of the original object. Contrast with <<deep_copy>>. Also see <<aliasing>>.

[[singleton]]singleton:: (((singletons)))(((objects, singletons)))An object that is the only existing instance of a class--usually not by accident but because the class is designed to prevent creation of more than one instance. There is also a design pattern named Singleton, which is a recipe for coding such classes. The `None` object is a singleton in Python.

[[slicing]]slicing:: (((slicing, definition of term)))(((sequences, slicing of)))Producing a subset of a sequence by using the slice notation, e.g., `my_sequence[2:6]`. Slicing usually copies data to produce a new object; in particular, `my_sequence[:]` creates a shallow copy of the entire sequence. But a `memoryview` object can be sliced to produce a new `memoryview` that shares data with the original object.

[[snake_case]]snake_case:: ((("snake_case")))The convention of writing identifiers by joining words with the underscore character (`_`)—for example, `run_until_complete`. PEP-8 calls this style "lowercase with words separated by underscores" and recommends it for naming functions, methods, arguments, and variables. For packages, PEP-8 recommends concatenating words with no separators. The Python standard library has many examples of `snake_case` identifiers, but also many examples of identifiers with no separation between words (e.g., `getattr`, `classmethod`, `isinstance`, `str.endswith`, etc.). See <<CamelCase>>.

[[special_method]]special method:: (((special methods, definition of term)))((("methods", "special", see="special methods")))A method with a special name such as pass:[<code class="keep-together">__getitem__</code>], spelled with leading and trailing double underscores. Almost all special methods recognized by Python are described in the http://bit.ly/1GsZwss["Data model" chapter] of _The Python Language Reference_, but a few that are used only in specific contexts are documented in other parts of the documentation. For example, the `+__missing__+` method of mappings is mentioned in http://bit.ly/1QS9Ong["4.10. Mapping Types — `dict`"] in _The Python Standard Library_.

[[storage_attribute]]storage attribute:: (((storage attributes)))(((attributes, storage)))An attribute in a <<managed_instance>> used to store the value of an attribute managed by a <<descriptor>>. See also <<managed attribute>>.

[[strong_reference]]strong reference:: (((strong references)))(((references, strong)))A reference that is counted in an object's <<refcount>>, and keeps that object alive in memory. Contrast with <<weak reference>>.

[[subject]]subject:: (((pattern matching, subject)))The value of the expression in the `match` clause. Python will try to match the pattern in each `case` clause to the subject.

[[T]]

[[tuple_unpacking]]tuple unpacking:: (((tuple unpacking, definition of term)))Assigning items from an iterable object to a tuple of variables (e.g., `first, second, third == my_list`). This is the usual term used by Pythonistas, but _iterable unpacking_ is gaining traction.

[[truthy]]truthy:: (((truthiness)))Any value `x` for which `bool(x)` returns `True`; Python implicitly uses `bool` to evaluate objects in Boolean contexts, such as the expression controlling an `if` or `while` loop. By default, a Python object is truthy unless their `+__bool__+` method returns `False`. See the short list of conventional <<falsy>> objects.

[[type]]type:: ((("type, definition of term")))Each specific category of program data, defined by a set of possible values and operations on them. Some Python types are close to machine data types (e.g., `float` and `bytes`) while others are extensions (e.g., `int` is not limited to CPU word size, `str` holds multibyte Unicode data points) and more high-level abstractions (e.g., `dict`, `deque`, etc.). Types may be user defined or built into the interpreter (a "built-in" type). Before the type/class unification in Python 2.2, types and classes were different entities, and user-defined classes could not extend built-in types. Since then, built-in types and new-style classes became compatible. Every new-style class is a subclass of the `object` <<class>> and an instance of the `type` built-in <<metaclass>>. In Python 3 all classes new-style classes.

[[U]]

[[unbound_method]]unbound method:: (((unbound methods)))(((methods, unbound)))An instance method accessed directly on a class is not bound to an instance; therefore it's said to be an "unbound method." To succeed, a call to an unbound method must explicitly pass an instance of the class as the first argument. That instance will be assigned to the `self` argument in the method. See <<bound method>>.

[[uniform_access_principle]]uniform access principle:: ((("uniform access principle")))Bertrand Meyer, creator of the Eiffel Language, wrote: "All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation." Properties and descriptors allow the implementation of the uniform access principle in Python. The lack of a `new` operator, making function calls and object instantiation look the same, is another form of this principle: the caller does not need to know whether the invoked object is a class, a function, or any other callable.

[[user-defined]]user-defined:: ((("user-defined", "definition of term")))Almost always in the Python docs the word _user_ refers to you and I--programmers who use the Python language--as opposed to the developers who implement a Python interpreter. So the term "user-defined class" means a class written in Python, as opposed to built-in classes written in C, like `str`.

[[V]]

[[view]]view:: Python 3 views are special data structures returned by the `dict` methods `.keys()`, `.values()`, and `.items()`, providing a dynamic view into the `dict` keys and values without data duplication (which occurs in Python 2 where those methods return lists). All `dict` views are iterable and support the `in` operator. In addition, if the items referenced by the view are all hashable, then the view also implements the `collections.abc.Set` interface. This is the case for all views returned by the `.keys()` method, and for views returned by `.items()` when the values are also hashable.

[[virtual_subclass]]virtual subclass:: (((virtual subclasses)))(((subclasses, virtual)))A class that does not inherit from an <<ABC,ABC>> but is registered using the `register` class method. For example, after `abc.Sequence.register(MySequence)`, the call `issubclass(MySequence, abc.Sequence)` returns `True`. See documentation for http://bit.ly/1DeDbKf[`abc.ABCMeta.register`].

[[W]]

[[warlus_operator]]walrus operator:: (((walrus operator)))Semi-official name for the ++:=++ operator, formally described in https://www.python.org/dev/peps/pep-0572/[PEP 572—Assignment Expressions]. Turn your head 90° to the left and think of a https://en.wikipedia.org/wiki/Walrus#/media/File:Walrus2.jpg[walrus] to understand why.

[[wart]]wart:: ((("warts, definition of term")))A misfeature of the language. Andrew Kuchling's famous post http://web.archive.org/web/20031002184114/www.amk.ca/python/writing/warts.html[Python warts] has been acknowledged by the <<BDFL>> as influential in the decision to break backward-compatibility in the design of Python 3, as most of the failings could not be fixed otherwise. Many of Kuchling's issues were fixed in Python 3. See https://wiki.python.org/moin/PythonWarts[Python Warts] in https://wiki.python.org[wiki.python.org].

[[weak_reference]]weak reference:: (((weak references)))(((references, weak)))A special kind of object reference that does not increase the <<refcount>> of the <<referent>> object. Weak references are created with one of the functions and data structures in the https://docs.python.org/3/library/weakref.html[`weakref`] module. Contrast with <<strong_reference>>.

[[Y]]

[[YAGNI]]YAGNI:: "You Ain't Gonna Need It," a slogan to avoid implementing functionality that is not immediately necessary based on assumptions about future needs.

[[Z]]

[[Zen_of_Python]]Zen of Python:: Type `import this` into any Python console since version 2.2.
